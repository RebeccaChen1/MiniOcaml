(* 
                         CS 51 Final Project
                         MiniML -- Evaluation
                             Spring 2017
*)

(* This module implements a small untyped ML-like language under
   various operational semantics.
 *)
    
open Expr ;;
  
(* Exception for evaluator runtime, generated by a runtime error *)
exception EvalError of string ;;
(* Exception for evaluator runtime, generated by an explicit "raise" construct *)
exception EvalException ;;
exception UnboundEnv ;;


(* Environments and values *)

module type Env_type = sig
    type env
    type value =
      | Val of expr
      | Closure of (expr * env)
    val create : unit -> env
    val close : expr -> env -> value
    val lookup : env -> varid -> value
    val extend : env -> varid -> value ref -> env
    val env_to_string : env -> string
    val value_to_string : ?printenvp:bool -> value -> string
  end

module Env : Env_type =
  struct
    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    (* Creates an empty environment *)
    let create () : env = [] ;;

    (* Creates a closure from an expression and the environment it's
       defined in *)
    let close (exp : expr) (env : env) : value =
      Closure (exp, env) ;;

    (* Looks up the value of a variable in the environment *)
    let lookup (env : env) (varname : varid) : value =
      try
        !(snd (List.find (fun x -> fst x = varname) env))
      with
        | Not_found -> raise UnboundEnv ;;

    (* Returns a new environment just like env except that it maps the
       variable varid to loc *)
    let rec extend (env : env) (varname : varid) (loc : value ref) : env =
      match env with
      | [] -> (varname, loc) :: []
      | (varid, varval) :: t ->
        if varid = varname then
          (varid, loc) :: t
        else
          (varid, varval) :: (extend t varname loc) ;;

    (* Returns a printable string representation of a value; the flag
       printenvp determines whether to include the environment in the
       string representation when called on a closure *)
  let rec value_to_string ?(printenvp : bool = true) (v : value) : string =
      match v with
      | Val exp -> "Val(" ^ exp_to_abstract_string exp ^ ")"
      | Closure (exp, env) -> 
        if printenvp then 
          "Closure(" ^ exp_to_abstract_string exp ^ ", " 
          ^ env_to_string env ^ ")"
        else 
          "Closure(" ^ exp_to_abstract_string exp ^ ", <env>)"

   (* Returns a printable string representation of an environment *)
   and env_to_string (env : env) : string =
     let rec env_to_string_inner env = 
       match env with
       | [] -> "]"
       | (id, val_ref) :: t ->
         (Printf.sprintf "(%s, %s);" id (value_to_string !val_ref)) 
         ^ env_to_string_inner t 
     in "[" ^ env_to_string_inner env ;;
  end
;;
  
(* The evaluation function: Returns the result of type `value` of
   evaluating the expression `exp` in the environment `env`. In this
   initial implementation, we just convert the expression unchanged to
   a value and return it. *)


(** The external evaluator, which can be either the identity function,
    the substitution model version or the dynamic or lexical
    environment model version. *)

let eval_t exp _env = exp ;;

let eval_s (exp : expr) (_env : Env.env) : Env.value =
  let rec eval_s_inner (exp : expr) : expr = 
    match exp with
    (* returns original expression unless unbound *)
    | Var _id -> raise (EvalError "Unbound variable")
    | Num _ | Bool _ | Fun _ -> exp
    (* expects a num in e and multiplies it by -1 *)
    | Unop (_u, e) -> 
      (match eval_s_inner e with
       | Num x -> Num (-1 * x)
       | _ -> raise (EvalError "Need Integer"))
    (* binop could match to nums and bools *)
    | Binop (bnp, e1, e2) -> 
      (match eval_s_inner e1, eval_s_inner e2 with
       | Num x, Num y -> 
         (match bnp with
          | Plus -> Num(x + y) 
          | Minus -> Num(x - y)
          | Times -> Num(x * y)
          | Equals -> Bool (x = y)
          | LessThan -> Bool (x < y))
       | Bool a, Bool b -> 
         (match bnp with
          | Equals -> Bool (a = b)
          | _ -> raise (EvalError ("invalid operator")))
       | _ -> raise (EvalError ("integers or bools expected")))
    | Conditional (e1, e2, e3) -> 
      (match eval_s_inner e1 with
       (* e1 needs to be a bool or a Equals/LessThan binop *)
       | Bool b -> if b then eval_s_inner e2 else eval_s_inner e3
       | Binop (bnp, ex1, ex2) -> 
         (match bnp with
          | Equals -> if eval_s_inner ex1 = eval_s_inner ex2 
                      then eval_s_inner e2 else eval_s_inner e3
          | LessThan -> if eval_s_inner ex1 < eval_s_inner ex2
                        then eval_s_inner e2 else eval_s_inner e3
          | _ -> raise (EvalError ("invalid operator")))
       | _ -> raise (EvalError ("bool or =/< expression expected")))
    (* substitute all occurences of id with the evaluated e1 *) 
    | Let (id, e1, e2) -> 
      let new_e1 = eval_s_inner e1 in 
        eval_s_inner (subst id new_e1 e2)
    (* substitutes occurences of id with the letrec def in evaluated e1 *)
    | Letrec (id, e1, e2) -> 
      let new_e1 = eval_s_inner (subst id (Letrec(id, e1, Var(id))) e1)
        in eval_s_inner (subst id new_e1 e2)
    | Raise -> raise EvalException
    | Unassigned -> raise (EvalError ("unassigned"))
    (* e1 must be a fun, substitutes id with evaluated e2 in the fun expr *)
    | App (e1, e2) -> 
      (match eval_s_inner e1 with
       | Fun (id, fe) -> let new_e2 = eval_s_inner e2 in 
                         eval_s_inner (subst id new_e2 fe)
       | _ -> raise (EvalError "function expected"))
    (* turns expr to Env.value *)
    in Env.Val (eval_s_inner exp)    
;;

(* factors out redundant code in eval_d and eval_l *)
(* i = 1 is dynamic and i = 0 is lexical *)
let rec eval_inner (exp : expr) (env : Env.env) (i : int): Env.value = 
  match exp with
  | Var id -> Env.lookup env id
  | Num _ | Bool _ -> Env.Val exp
  | Unop (_u, e) ->
    (match eval_inner e env i with
     | Env.Val (Num x) -> Env.Val (Num (-1 * x))
     | _ -> raise (EvalError ("unop expects an integer")))
  | Binop (bnp, e1, e2) ->
    (match eval_inner e1 env i, eval_inner e2 env i with
     | Env.Val (Num x), Env.Val (Num y) -> 
       (match bnp with
        | Plus -> Env.Val (Num (x + y))
        | Minus -> Env.Val (Num (x - y))
        | Times -> Env.Val (Num (x * y))
        | Equals -> Env.Val (Bool (x = y))
        | LessThan -> Env.Val (Bool (x < y)))
     | Env.Val (Bool a), Env.Val (Bool b) ->
       (match bnp with
       | Equals -> Env.Val (Bool (a = b))
       | _ -> raise (EvalError ("invalid operator")))
    | _ -> raise (EvalError ("integers or bools expected")))
  | Conditional (e1, e2, e3) -> 
    (match eval_inner e1 env i with
     | Env.Val (Bool b) -> if b then eval_inner e2 env i 
                           else eval_inner e3 env i
     | Env.Val (Binop (b, be1, be2)) ->
       (match b with
        | Equals -> if eval_inner be1 env i = eval_inner be2 env i
                    then eval_inner e2 env i else eval_inner e3 env i
        | LessThan -> if eval_inner be1 env i < eval_inner be2 env i
                      then eval_inner e2 env i else eval_inner e3 env i
        | _ -> raise (EvalError ("invalid operator")))
      | _ -> raise (EvalError ("invalid conditional statement")))
    (* evaluates e2 in extended environment of e1 *)
  | Let (id, e1, e2) -> 
    let new_e1 = eval_inner e1 env i in
    eval_inner e2 (Env.extend env id (ref new_e1)) i 
  | Raise -> raise EvalException
  | Unassigned -> raise UnboundEnv
  | Fun _ -> if i = 1 
             (* dynamic application, returns itself *)
             then Env.Val (exp)
             (* lexical application, returns closure *) 
             else Env.close exp env
  | Letrec (id, e1, e2) ->
    if i = 1 
    (* dynamic application *)
    (* extends new env with unassigned value *)
    then let env1 = Env.extend env id (ref (Env.Val Unassigned)) in
         (* evaluates e1 in new env *)
         let new_e1 = eval_inner e1 env1 i in
         (* extends new env with evaluated e1 *)
         let env2 = Env.extend env1 id (ref new_e1) in
         (* evaluates e2 in second new env *)
         eval_inner e2 env2 i
    (* lexical application, similar to dynamic but mutates
       unassigned ref to the evaluated e1 consistent with lexical scoping *)
    else let ref_unassigned = ref (Env.Val Unassigned) in
         let env1 = Env.extend env id ref_unassigned in
         let new_e1 = eval_inner e1 env1 i in
         let env2 = Env.extend env1 id (ref new_e1) in
         ref_unassigned := new_e1 ;
         eval_inner e2 env2 i
  | App (e1, e2) ->
    if i = 1 
    (* dynamic application *)
    then (match eval_inner e1 env i with
          | Env.Val (Fun (id, e)) -> 
            let new_e2 = eval_inner e2 env i in
            eval_inner e (Env.extend env id (ref new_e2)) i
          | _ -> raise (EvalError ("function expected")))
    (* lexical application, evaluates the body of the function in the
       lexical environment from the corresponding closure *)
    else  (match eval_inner e1 env i with
           | Env.Closure (Fun (id, e), env0) -> 
             let new_e2 = eval_inner e2 env i in
             eval_inner e (Env.extend env0 id (ref new_e2)) i
           | _ -> raise (EvalError "function expected")) 
 
let eval_d (exp : expr) (env : Env.env) : Env.value = 
  eval_inner exp env 1 ;;

let eval_l (exp : expr) (env: Env.env) : Env.value = 
  eval_inner exp env 0 ;;                            

let evaluate = eval_l ;;
